<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Nymi SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<!-- <link href="doxygen.css" rel="stylesheet" type="text/css" /> -->
<link href="customStylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top" bgcolor=#37bec4><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
<tr style="height: 0em;">
  <td id='logoBox'>
  <img  id='logoImg' src ="logo.png"></a>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
			<img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
			<img id="MSearchSelect" src="search/mag_sel.png" alt="">
			<input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hello_nymi_tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Hello Nymi </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial we will create a basic <a class="el" href="_n_e_a.html">NEA</a> using the <a class="el" href="_n_c_l.html">NCL</a>. The NEA will be able to <a class="el" href="provisioning.html">provision</a> and <a class="el" href="validation.html">validate</a> <a class="el" href="_nymi.html">Nymis</a>. For example, we might be creating an email system that uses Nymis instead of usernames and passwords. In this case, provisioning is like creating an account and validation is like signing in. Note that though most actual email services will sign a user in when they are created, these are distinct processes, and provisioning a Nymi doesn't mean it is validated.</p>
<p><br />
 </p><h1>Skeleton </h1>
<p>Let's dive into the code. We'll use C++. First we include the NCL and some standard libraries we'll use. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ncl.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
</div><!-- fragment --><p> Then we create a main function, and the first thing we do is initialize the NCL. <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a> attempts to kick off some longer-running initializations. If <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a> returns <a class="el" href="group__core_types.html#gga8b29ab53ed14da3e785ac485cfe885d3aa08f5c833087f263fbe6a3eaecdb1eb6">NCL_FALSE</a>, the attempt failed and we exit. When the longer-running initializations finish or fail, our callback will receive an <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba0d35d2970076d03090254143ac3317ca">NCL_EVENT_INIT</a>. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>* argv[]){</div>
<div class="line">    <span class="comment">//init</span></div>
<div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a>(callback, NULL, <span class="stringliteral">&quot;HelloNymi&quot;</span>, <a class="code" href="group__core_types.html#gga32500a62285dd90003982803d8869aa6a922f270f69469e7929969f07d9ecedb0">NCL_MODE_DEV</a>, stderr)) <span class="keywordflow">return</span> -1;</div>
</div><!-- fragment --><p> The parameters of <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a> mean the following:</p><ol type="1">
<li><code>callback</code>: Our callback function, which we will start writing momentarily.</li>
<li><code>NULL</code>: Here we can choose to pass data to our callback, but we don't need to, so we pass NULL.</li>
<li><code>HelloNymi</code>: The default name of our NEA. The user will be able to see this name when using the <a class="el" href="companion_app.html">Companion App</a>, and it helps them disambiguate us from other NEAs they provisioned.</li>
<li><code>NCL_FALSE</code>: We will run the NCL in asynchronous mode. See <a class="el" href="introduction.html#concurrency_sub">Concurrency</a> for more information.</li>
<li><code>stderr</code>: We will direct NCL error messages to stderr.</li>
</ol>
<p>Let's define a global variable <code>gNclInitialized</code> that keeps track of whether or not NCL is initialized yet. It'll start false and become true if initialization succeeds. It goes just under the includes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> gNclInitialized=<span class="keyword">false</span>;</div>
</div><!-- fragment --><p> Then let's start defining our callback, just above the main: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> callback(<a class="code" href="struct_ncl_event.html">NclEvent</a> event, <span class="keywordtype">void</span>* userData){</div>
</div><!-- fragment --><p> The first parameter is an event sent by the NCL, and the second parameter is the custom data we set with <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a>, in this case NULL.</p>
<p>We make a switch statement depending on the type of the event received. Remember we called <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a> and this will cause an <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba0d35d2970076d03090254143ac3317ca">NCL_EVENT_INIT</a>, so let's write that case and have it check for success and either set <code>gNclInitialized</code> to true or exit. </p><div class="fragment"><div class="line">    <span class="keywordflow">switch</span>(event.<a class="code" href="struct_ncl_event.html#a582e9d5ff7422d1a2dc49d38b4013deb">type</a>){</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba0d35d2970076d03090254143ac3317ca">NCL_EVENT_INIT</a>:</div>
<div class="line">            <span class="keywordflow">if</span>(event.<a class="code" href="struct_ncl_event.html#a6fd83ba946479bd341f7b34670d4d99e">init</a>.<a class="code" href="struct_ncl_event_init.html#aae919d9ea26441d1137e0d6580552df1">success</a>) gNclInitialized=<span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">else</span> exit(-1);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011bad429fcb36cf410b96b41a32bdbfd97b3">NCL_EVENT_ERROR</a>:</div>
<div class="line">            exit(-1);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p> Additionally, we might get an <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011bad429fcb36cf410b96b41a32bdbfd97b3">NCL_EVENT_ERROR</a> any time after we've initialized. To keep it simple, we'll just exit if this happens. A better program would try to recover or fail gracefully.</p>
<p>You can read more about the event-driven nature of NCL and how to access members of <a class="el" href="struct_ncl_event.html">NclEvent</a> in the <a class="el" href="introduction.html#interface_sub">Library Interface</a>.</p>
<p>Next let's fill out our main function.</p>
<div class="fragment"><div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Welcome to Hello Nymi!\n&quot;</span>;</div>
<div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Enter \&quot;provision\&quot; if you want to start trusting a new Nymi.\n&quot;</span>;</div>
<div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Enter \&quot;validate\&quot; if you want to find trusted Nymis and validate the first one found.\n&quot;</span>;</div>
<div class="line">    std::cout&lt;&lt;<span class="stringliteral">&quot;Enter \&quot;quit\&quot; to quit.\n&quot;</span>;</div>
<div class="line">    <span class="comment">//loop</span></div>
<div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>){</div>
<div class="line">        std::string input;</div>
<div class="line">        std::cin&gt;&gt;input;</div>
<div class="line">        <span class="keywordflow">if</span>(!gNclInitialized){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;error: NCL didn&#39;t finished initializing yet!\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;provision&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: starting discovery\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#ga8b00c2e459aac27f86c16fad884610ce">nclStartDiscovery</a>();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;agree&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: provisioning\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#gab72e9445dd64bc661f63b0d96ec75585">nclProvision</a>(gHandle);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;reject&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: disconnecting\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#gacf1345da6ce70ca18d044babe3c65c71">nclDisconnect</a>(gHandle);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;validate&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: starting finding\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#ga4ca57669bd223a1395b80b206fb71e89">nclStartFinding</a>(gProvisions.data(), gProvisions.size(), <a class="code" href="group__core_types.html#gga8b29ab53ed14da3e785ac485cfe885d3aa08f5c833087f263fbe6a3eaecdb1eb6">NCL_FALSE</a>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;disconnect&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: disconnecting\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#gacf1345da6ce70ca18d044babe3c65c71">nclDisconnect</a>(gHandle);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;quit&quot;</span>) <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> We print out instructions, then read user input in the main loop, checking that the NCL has been initialized. If the user wants to quit, we break out of the main loop. We'll go through the other inputs throughout the rest of the tutorial.</p>
<p><br />
 </p><h1>Provisioning </h1>
<p>Upon launch, we have no Nymis to trust; no users. So, because we can't do anything else until we have some users, let's figure out how to create some users. We will use Nymi provisioning to do so. Recall this input in the main loop:</p>
<div class="fragment"><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;provision&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: starting discovery\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#ga8b00c2e459aac27f86c16fad884610ce">nclStartDiscovery</a>();</div>
<div class="line">        }</div>
</div><!-- fragment --><p> This starts discovery, which is the first step in provisioning for an NEA. An NEA can't provision any Nymi it finds; the Nymi wearer must first put their Nymi into the provisioning state. Provisioning Nymis can be discovered. When a provisioning Nymi is discovered, an <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011bac63c43d3ad37f7d2fd4ff6a1678a4de5">NCL_EVENT_DISCOVERY</a> is sent to our callback. So let's write that case.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011bac63c43d3ad37f7d2fd4ff6a1678a4de5">NCL_EVENT_DISCOVERY</a>:</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: Nymi discovered\n&quot;</span>;</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: stopping scan\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#ga825ba39e62b86781e8e0f36fbd8c87c6">nclStopScan</a>();</div>
<div class="line">            gHandle=<span class="keyword">event</span>.discovery.nymiHandle;</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: agreeing\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#ga75efc81655ffa0b171ec77f73fb8c95c">nclAgree</a>(event.<a class="code" href="struct_ncl_event.html#ade39004bf5500b48e58b10d5e3648381">discovery</a>.<a class="code" href="struct_ncl_event_discovery.html#aea279960177909e2975e816f6b7af538">nymiHandle</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p> We handle the event by stopping further scanning, then calling <a class="el" href="group__negotiation_functions.html#ga75efc81655ffa0b171ec77f73fb8c95c">nclAgree</a>, which establishes a <a class="el" href="connection.html">connection</a> and derives an LED pattern. The Nymi will display this pattern, and we are responsible for doing the same. This allows the user to verify the correct Nymi and NEA have found each other. An <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011bace67ca079d7623054f69616274953dcf">NCL_EVENT_AGREEMENT</a> is sent to the callback function when agreement completes. Failure is implied if an <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba169f0c1c332a8d036691ba85525da51a">NCL_EVENT_DISCONNECTION</a> is received first. In any case, we have to be ready for a disconnection because of the connection established by <a class="el" href="group__negotiation_functions.html#ga75efc81655ffa0b171ec77f73fb8c95c">nclAgree</a>. We also keep track of the connected Nymi with <code>gHandle</code> so we can do other things with it. We define <code>gHandle</code> with our other global, just below our includes. Nymi handles are always positive, so we can use -1 to mean no Nymi is connected, which is initially true.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> gHandle=-1;</div>
</div><!-- fragment --><p> Let's quickly look at how we'll handle disconnects.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba169f0c1c332a8d036691ba85525da51a">NCL_EVENT_DISCONNECTION</a>:</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: disconnected\n&quot;</span>;</div>
<div class="line">            gHandle=-1;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p> We set <code>gHandle</code> back to -1 to indicate no connected Nymi. This is relevant throughout the rest of provisioning and in validation, but this behavior is fine for all cases.</p>
<p>Back to provisioning, we discovered a Nymi and tried to agree with it, so we're waiting on an agreement event. Let's implement that case in our callback:</p>
<div class="fragment"><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011bace67ca079d7623054f69616274953dcf">NCL_EVENT_AGREEMENT</a>:</div>
<div class="line">            gHandle=<span class="keyword">event</span>.agreement.nymiHandle;</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;Is this:\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;<a class="code" href="group__negotiation_constants.html#ga6545350a1d021fb6923c4e7999f796b7">NCL_AGREEMENT_PATTERNS</a>; ++i){</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0; j&lt;<a class="code" href="group__negotiation_constants.html#ga73d7fd893995113ea91c2fdeca990c74">NCL_LEDS</a>; ++j)</div>
<div class="line">                    std::cout&lt;&lt;event.<a class="code" href="struct_ncl_event.html#ae964977939f1e63d5a0524e49400ba37">agreement</a>.<a class="code" href="struct_ncl_event_agreement.html#a79e0ca7052f56d6cc951f65ba7ca990c">leds</a>[i][j];</div>
<div class="line">                std::cout&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            }</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;the correct LED pattern (agree/reject)?\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p> All we do here is print the LED pattern to the console for the user to see. Remember these input options in the main loop?</p>
<div class="fragment"><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;agree&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: provisioning\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#gab72e9445dd64bc661f63b0d96ec75585">nclProvision</a>(gHandle);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;reject&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: disconnecting\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#gacf1345da6ce70ca18d044babe3c65c71">nclDisconnect</a>(gHandle);</div>
<div class="line">        }</div>
</div><!-- fragment --><p> The user can either type "agree" if the LED patterns match, or "reject" if they don't. If the user confirmed the match, then we try to finish the provisioning process with <a class="el" href="group__negotiation_functions.html#gab72e9445dd64bc661f63b0d96ec75585">nclProvision</a>, and otherwise we disconnect.</p>
<p>If the provision is successful, we will receive <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba6ebcb291ed57474ed99890e8efd544f0">NCL_EVENT_PROVISION</a> in the callback, and then the Nymi will be disconnected. We will store the new provision in a global variable <code>gProvisions</code>.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba6ebcb291ed57474ed99890e8efd544f0">NCL_EVENT_PROVISION</a>:</div>
<div class="line">            gProvisions.push_back(event.<a class="code" href="struct_ncl_event.html#a429c7e66a53f3ebdbe0c5dcc47359540">provision</a>.<a class="code" href="struct_ncl_event_provision.html#a22c201897d9145e04c1b69415d91214d">provision</a>);</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: provisioned\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p> We define <code>gProvisions</code> with our other globals just below our includes: </p><div class="fragment"><div class="line">std::vector&lt;NclProvision&gt; gProvisions;</div>
</div><!-- fragment --><p> So, we've followed the dance the NEA and Nymi go through to establish a provision, implementing code along the way, and now we can provision Nymis. We can create users. The next step is to let users sign in.</p>
<p><br />
 </p><h1>Validation </h1>
<p>The most important aspect of validating a Nymi is that we now know it is the exact same Nymi, and therefore wearer, that we provisioned before. An NEA whose validated a Nymi also has access to a slew of other Nymi functionalities, including <a class="el" href="group__streams.html">Streams</a> and <a class="el" href="group__security.html">Security Tools</a>, but we don't need any of these here.</p>
<p>The first step toward validating is <a class="el" href="finding.html">finding</a> the previously provisioned Nymi. Finding a Nymi doesn't establish a connection, so the Nymi won't know the NEA is nearby, and it only provides a weak amount of certainty that this is the same Nymi as before. So, when the user types in "validate", we call <a class="el" href="group__negotiation_functions.html#ga4ca57669bd223a1395b80b206fb71e89">nclStartFinding</a>.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;validate&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: starting finding\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#ga4ca57669bd223a1395b80b206fb71e89">nclStartFinding</a>(gProvisions.data(), gProvisions.size(), <a class="code" href="group__core_types.html#gga8b29ab53ed14da3e785ac485cfe885d3aa08f5c833087f263fbe6a3eaecdb1eb6">NCL_FALSE</a>);</div>
<div class="line">        }</div>
</div><!-- fragment --><p> The parameters mean the following:</p><ol type="1">
<li><code>gProvisions.data()</code>: An array of provisions.</li>
<li><code>gProvisions.size()</code>: The number of provisions in the array.</li>
<li><code>NCL_FALSE</code>: Don't <a class="el" href="detection.html">detect</a> Nymis.</li>
</ol>
<p>When a provisioned Nymi is found, we receive <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba10b2ad405430ac6efa145f35f0711d43">NCL_EVENT_FIND</a> in the callback. Once we do, we stop scanning and validate the Nymi. Validating a Nymi establishes a connection, so we set <code>gHandle</code> here too.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba10b2ad405430ac6efa145f35f0711d43">NCL_EVENT_FIND</a>:</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: Nymi found\n&quot;</span>;</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: stopping scan\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#ga825ba39e62b86781e8e0f36fbd8c87c6">nclStopScan</a>();</div>
<div class="line">            gHandle=<span class="keyword">event</span>.find.nymiHandle;</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: validating\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#ga7db0235691855d0590a9bc6e9e55496c">nclValidate</a>(event.<a class="code" href="struct_ncl_event.html#afff69d49adef21da5e8a46618bf3ddb4">find</a>.<a class="code" href="struct_ncl_event_find.html#ac1c208faba2a52b577fb32396cca6a4b">nymiHandle</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p> If the Nymi is validated, <a class="el" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba465a5e4c2c3a8122843a09ce405a6a16">NCL_EVENT_VALIDATION</a> will be sent to the callback.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__core_types.html#gga3aef10678c713279bbd891e6fba6011ba465a5e4c2c3a8122843a09ce405a6a16">NCL_EVENT_VALIDATION</a>:</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;Nymi validated! Now trusted user stuff can happen.\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Now the Nymi is validated. This means we know who the wearer is and that we trust them. Therefore we can let them, say, send an email.</p>
<p><br />
 </p><h1>Disconnecting </h1>
<p>When the user is done, they will want to sign out. Disconnecting is the Nymi equivalent. The user can disconnect from an NEA with their Nymi, but we'll also let them disconnect their Nymi from the NEA.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(input==<span class="stringliteral">&quot;disconnect&quot;</span>){</div>
<div class="line">            std::cout&lt;&lt;<span class="stringliteral">&quot;log: disconnecting\n&quot;</span>;</div>
<div class="line">            <a class="code" href="group__negotiation_functions.html#gacf1345da6ce70ca18d044babe3c65c71">nclDisconnect</a>(gHandle);</div>
<div class="line">        }</div>
</div><!-- fragment --><p> We do the same thing here as for the "reject" command.</p>
<p><br />
 </p><h1>Cleanup </h1>
<p>Finally, let's look what happens when the user quits, just after the main loop.</p>
<div class="fragment"><div class="line">    <span class="comment">//finish</span></div>
<div class="line">    <span class="keywordflow">if</span>(gHandle!=-1) <a class="code" href="group__negotiation_functions.html#gacf1345da6ce70ca18d044babe3c65c71">nclDisconnect</a>(gHandle);</div>
<div class="line">    <a class="code" href="group__core_functions.html#gae9b1705fe263a7cd31e82cde14917119">nclFinish</a>();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We check for a connected Nymi, and if there is one, disconnect it. Then we call <a class="el" href="group__core_functions.html#gae9b1705fe263a7cd31e82cde14917119">nclFinish</a>, and we're done! </p><hr/>
<p><b>Next:</b></p><ul>
<li>Learn to <a class="el" href="store_provision_tutorial.html">store provisions</a></li>
<li>Dive into the <a href="modules.html">reference </a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--   <ul>
    <li class="footer">Copyright Bionym 2013. Generated on Thu Sep 25 2014. Version 0.1.0</li>
  </ul> -->
</div>
<!-- end header part -->
