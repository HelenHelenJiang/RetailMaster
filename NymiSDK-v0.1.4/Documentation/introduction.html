<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Nymi SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<!-- <link href="doxygen.css" rel="stylesheet" type="text/css" /> -->
<link href="customStylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top" bgcolor=#37bec4><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
<tr style="height: 0em;">
  <td id='logoBox'>
  <img  id='logoImg' src ="logo.png"></a>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
			<img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
			<img id="MSearchSelect" src="search/mag_sel.png" alt="">
			<input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('introduction.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="capabilities_sub"></a>
Capabilities of the Nymi</h1>
<p>Nymi-Enabled Applications (NEAs) are programs that run on Bluetooth-enabled devices such as Smartphones and computers. These applications communicate with the Nymi using Bluetooth Low Energy (BLE). Before developing an app that interacts with the Nymi, it is important to understand what the Nymi is capable of.</p>
<div class="image">
<img src="nymi_outputs.png" alt="nymi_outputs.png"/>
</div>
 <h2>Data Generated by the Nymi</h2>
<p>Other than authenticating the identity of the wearer, a Nymi-Enabled-Application can also access the following data:</p><ul>
<li>Proximity through RSSI reading</li>
<li>6-axis motion through accelerometer and gyroscope</li>
<li>Electrocardiogram (ECG)</li>
</ul>
<p>The <a class="el" href="group__streams.html">Streams</a> section of the Nymi Communication Library Reference contains functions for reading ECG, accelerometer and gyroscope data. <a class="el" href="group__misc_functions.html#gae33cfc37b1d399f37bcd95ab89f288f5">nclGetRssi</a> queries the Nymi for RSSI values.</p>
<h2>Notifications to the User</h2>
<p>A Nymi can provide feedback to the wearer in two ways:</p><ul>
<li>Visual: there are 5 LED lights located on the side of the centerpiece</li>
<li>Haptic: there is a vibration motor located in the wristband</li>
</ul>
<p>The LED lights and the vibration motor are primarily used for built-in operations such as reporting the state of the Nymi. However, Nymi-Enabled Applications can use them for simple notifications through <a class="el" href="group__misc_functions.html#ga815059336ba7599dca45d20958491171">nclNotify</a>.</p>
<h2>Cryptographic Key Generation and Management</h2>
<p>The Nymi can be used to generate and manage <a class="el" href="group__security_functions.html#ga8350c519c969bdd5490a699251caded0">symmetric keys</a>, <a class="el" href="group__security_functions.html#ga342a2d82b8de6e0fe84efc911001d8bf">asymmetric key pairs</a> for signatures, and <a class="el" href="group__security_functions.html#ga2586c97f9b96ff731b6b565394ccd7f4">pseudorandom values</a>.</p>
<p><br />
 </p><hr/>
<p><br />
<br />
</p>
<h1><a class="anchor" id="coreconcepts_sub"></a>
How the Nymi Identifies Its Wearer</h1>
<h2>Enrollment and Authentication</h2>
<p>The Nymi identifies wearers based on their electrocardiogram (ECG). When a user puts on their Nymi for the first time, a comprehensive ECG profile is created and saved. This process is named enrollment. The next time that the same user puts on the same Nymi, ECG is captured and matched to the stored profile. This process is named authentication.</p>
<p>Both enrollment and authentication is conducted with the Nymi Companion App - an app that is provided along with the Nymi and developed by Bionym Inc. The Companion App is installed onto the user's device, such as a Smartphone or a computer. The Nymi maintains the authenticated state as long as it remains on the wrist of the user - without further ECG reading. Nymi-Enabled Applications can only detect and interact with authenticated Nymis.</p>
<p>To make development easier, a Nymi may be set to "developer mode", where it is always authenticated.</p>
<h2>Provision and Validation</h2>
<p>A provision is a bridge between a Nymi-Enabled Application and a Nymi. After the bridge is established, the application can detect and communicate with the same Nymi in the future. Once a provision is established, it persists until the Nymi undergoes factory reset, or when the user opts out of the app using the Nymi Companion App. You give a name to your app when you call <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a>, this is the name that appers in the Nymi Companion App.</p>
<p>An application can look for a previously-provisioned Nymi through a process called validation. Once the Nymi has been validated, application-specific behaviour can occur and data can be collected from the Nymi through NCL function calls. The only exception is <a class="el" href="group__security_functions.html#gaca668c6614f5e446c57d0c5e936fb01b">nclGlobalSign</a>, which does not require the Nymi to be validated. As a developer, you need to take care of both the provision and validation through the sequence of function calls listed in the section <a class="el" href="introduction.html#workflow_sub">below</a>.</p>
<div class="image">
<img src="core_concepts.png" alt="core_concepts.png"/>
</div>
<blockquote class="doxtable">
<p>To learn more about the technology behind the Nymi, please refer to our <a href="http://bionym.com/resources/NymiWhitePaper.pdf">white paper</a>. </p>
</blockquote>
<p><br />
 </p><hr/>
<p><br />
<br />
</p>
<h1><a class="anchor" id="interface_sub"></a>
Working with the Nymi Communication Library</h1>
<p>The Nymi Communication Library (NCL) is an API for creating Nymi-Enabled Applications (NEAs). It wraps the Bluetooth Low Energy and Nymi communication protocols and provides the means for your application to establish a secure communication channel with the Nymi.</p>
<div class="image">
<img src="event_callback.png" alt="event_callback.png"/>
</div>
 <h2>Event-Driven Programming</h2>
<p>The Nymi Communication Library operates in an event-driven manner.</p>
<p>NCL functions return almost immediately after they are called. The return type of most NCL functions is <a class="el" href="group__core_types.html#ga8b29ab53ed14da3e785ac485cfe885d3">NclBool</a>, <em>true</em> indicates a successful initiation of processes, and <em>false</em> indicates an unsuccessful initiation. Even after an NCL function returns, the processes that it starts will continue to run and trigger events of the type <a class="el" href="struct_ncl_event.html">NclEvent</a>. Each function will produce at least one event. You must define a callback function and supply it to <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a>. You may optionally add more callback functions with <a class="el" href="group__core_functions.html#ga1fabff6d12470f7a99ee83fbf4afcd11">nclAddBehavior</a>.</p>
<p>Most NCL functions cannot be called safely unless the processes started by the previous function have finished. Generally, you would use the callback function to call the next NCL function.</p>
<h2><a class="anchor" id="nclevent_sec"></a>
Working with NclEvent</h2>
<p><a class="el" href="struct_ncl_event.html">NclEvent</a> is a struct with two members: one that defines the type of event, and one that carries the associated data.</p>
<ol type="1">
<li><b>Type</b>: <code>NclEvent sampleEvent</code> can be queried using <code>sampleEvent.type</code> to determine what type of event it represents. Visit the <a class="el" href="group__core_types.html#ga3aef10678c713279bbd891e6fba6011b">NclEventType enum definition</a> for a list of all the possible event types.</li>
<li><b>Data</b>: The data-containing member of <a class="el" href="struct_ncl_event.html" title="The NCL is event-driven. NclEvent is a struct that represents an event triggered by an NCL operation...">NclEvent</a> is implemented as an <a href="http://www.cplusplus.com/doc/tutorial/other_data_types/#unions" target="_blank">anonymous union</a>, meaning that it has different names and should be interpreted differently depending on the type of event. The <a class="el" href="struct_ncl_event.html">NclEvent reference page</a> shows you which event types correspond to which data-containing members. For example, if <code>sampleEvent.type</code> is "NCL_EVENT_CREATED_SK", then its data can be accessed using <code>sampleEvent.sk</code>.</li>
</ol>
<p>Each data-containing member of <a class="el" href="struct_ncl_event.html" title="The NCL is event-driven. NclEvent is a struct that represents an event triggered by an NCL operation...">NclEvent</a> is implemented as a struct as well, and therefore has its own sub-members. <code>sampleEvent.sk.id</code> holds the ID of the symmetric key, and <code>sampleEvent.sk.nymiHandle</code> holds the handle of the Nymi that is sending a symmetric key. You can view these sub-members by clicking on the struct types listed on the left column of the <a class="el" href="struct_ncl_event.html" title="The NCL is event-driven. NclEvent is a struct that represents an event triggered by an NCL operation...">NclEvent</a> reference page.</p>
<h2>Nymi Handles</h2>
<p>Nymi handles are temporary identifiers used to keep track of Nymis during a single run of a Nymi-Enabled Application.</p>
<p>After a Nymi has been detected, the NCL assigns an integer handle to it and puts the handle in the <code>.nymiHandle</code> member of event types such as <a class="el" href="struct_ncl_event_discovery.html">NclEventDiscovery</a> (during provisioning) and <a class="el" href="struct_ncl_event_find.html">NclEventFind</a> (during validation).</p>
<p>You application would then need to refer to a Nymi by its handle when you send commands, by supplying it as a parameter to NCL functions such as <a class="el" href="group__stream_functions.html#ga8ca8a1393748d73bd30df9a096832d15">nclStartGestureStream</a>. It is a good idea to store the Nymi handle as a global variable in your application.</p>
<p><br />
 </p><hr/>
<p><br />
<br />
</p>
<h1><a class="anchor" id="workflow_sub"></a>
Typical Application Workflow</h1>
<div class="image">
<img src="sequence.png" alt="sequence.png"/>
</div>
<p> Before calling any Nymi Communication Library (NCL) functions, your application must initiate the library using <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a>. Your application must also end with <a class="el" href="group__core_functions.html#gae9b1705fe263a7cd31e82cde14917119">nclFinish</a>.</p>
<h2>Provisioning</h2>
<p>The first time that a Nymi-Enabled Application encounters a particular Nymi, trusted communication hasn't been established yet. A provision needs to be set up between the Nymi and the application, and saved for later use.</p>
<ol type="1">
<li>Call <a class="el" href="group__negotiation_functions.html#ga8b00c2e459aac27f86c16fad884610ce">nclStartDiscovery</a> to scan for Nymis that are in the provisioning state. The user must put the Nymi in the provisioning state by double tapping it twice in succession.</li>
<li>Agree with a found Nymi using <a class="el" href="group__negotiation_functions.html#ga75efc81655ffa0b171ec77f73fb8c95c">nclAgree</a>. On completion, a shared session key is set up. From this, an LED pattern is derived. The Nymi displays this pattern. You should display this same pattern in your application so that the user can confirm that the correct Nymi is connected. Displaying the LED pattern and waiting for the user's confirmation is not mandatory, but strongly recommended in case there is more than one provisioning Nymi in the vicinity.</li>
<li>Call <a class="el" href="group__negotiation_functions.html#gab72e9445dd64bc661f63b0d96ec75585">nclProvision</a> after the user has confirmed the LED pattern.</li>
<li>Upon successful provisioning, store the provision key and ID for later use. Generally, you should store them on the local device. There are no limits to how many Nymis you can provision to an application.</li>
</ol>
<blockquote class="doxtable">
<p>Provision keys are secret keys, and are used by the Nymi to ensure that it is communicating with a trusted application, and by the application to ensure that it is communicating with a trusted Nymi. Sharing provision keys and ID's with other devices or applications creates a security threat and should be avoided. </p>
</blockquote>
<h2>Validation</h2>
<p>For an application to securely communicate with a Nymi, it must validate that it has been previously provisioned.</p>
<ol type="1">
<li>Load up stored provision(s), then start finding specific Nymi(s) with <a class="el" href="group__negotiation_functions.html#ga4ca57669bd223a1395b80b206fb71e89">nclStartFinding</a></li>
<li>Upon finding a Nymi, validate the Nymi with <a class="el" href="group__negotiation_functions.html#ga7db0235691855d0590a9bc6e9e55496c">nclValidate</a></li>
<li>Application specific behaviour</li>
<li>Disconnect from the Nymi with <a class="el" href="group__negotiation_functions.html#gacf1345da6ce70ca18d044babe3c65c71">nclDisconnect</a></li>
</ol>
<h2>Handling Disconnections</h2>
<p>Both <a class="el" href="group__negotiation_functions.html#ga75efc81655ffa0b171ec77f73fb8c95c">nclAgree</a> (as a part of the provisioning process) and <a class="el" href="group__negotiation_functions.html#ga7db0235691855d0590a9bc6e9e55496c">nclValidate</a> (as a part of the validation process) will set up a connection between the application and the Nymi upon successful completion. For provisioning, <a class="el" href="group__negotiation_functions.html#gab72e9445dd64bc661f63b0d96ec75585">nclProvision</a> will automatically disconnect after the provision is complete. For validation, you have to manually disconnect before finishing the program, by calling <a class="el" href="group__negotiation_functions.html#gacf1345da6ce70ca18d044babe3c65c71">nclDisconnect</a>.</p>
<p>On rare occasions, a disconnection may happen unexpectedly. It is good practice to catch "NCL_EVENT_DISCONNECTION" in a callback function, and handle it appropriately according to the disconnection reason. The <a class="el" href="troubleshooting.html#disconnection_sub">Troubleshooting</a> section gives you more guidance.</p>
<p><br />
 </p><hr/>
<p><br />
<br />
</p>
<h1><a class="anchor" id="concurrency_sub"></a>
Concurrency Modes</h1>
<p>Under most scenarios, it makes sense to operate the Nymi Communication Library in an asynchronous mode, where each callback happens in its own thread. No two callbacks will ever happen simultaneously. Most library functions can be safely called from multiple threads, the exceptions are documented with "not thread safe".</p>
<p>If you would like only one thread in your program, you can use the synchronous mode. You must then call <a class="el" href="group__core_functions.html#gae13a9dc004c43a8657e594b711d7878f">nclUpdate</a> regularly. nclUpdate will make a queue of events, and run the callbacks for all the events that has been accumulated since it was last called. nclUpdate will return once the callbacks have been executed.</p>
<p>You can set the concurrency mode in the <code>synchronous</code> parameter of <a class="el" href="group__core_functions.html#gaab7a0e4c6676fc35a6f7ef0f09100b57">nclInit</a>.</p>
<p><br />
 </p><hr/>
<p><br />
<br />
</p>
<h1><a class="anchor" id="exclusive_sub"></a>
Exclusive Procedures</h1>
<p>Some functions are documented as requiring the use of the Nymi's command channel. Only one of these functions can run at any one time.</p>
<p><br />
 </p><hr/>
<p><b>Next:</b></p><ul>
<li>Read a walk-through of a <a class="el" href="hello_nymi_tutorial.html">basic program</a></li>
<li>Dive into the <a href="modules.html">reference </a></li>
<li>Read the Nymi <a href="http://bionym.com/resources/NymiWhitePaper.pdf">white paper</a> if you'd like to learn more about the underlying technology </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--   <ul>
    <li class="footer">Copyright Bionym 2013. Generated on Thu Sep 25 2014. Version 0.1.0</li>
  </ul> -->
</div>
<!-- end header part -->
